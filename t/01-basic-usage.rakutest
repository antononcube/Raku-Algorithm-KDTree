use v6.d;
use Test;

use lib <. lib>;

use Algorithm::KDimensionalTree;

plan *;

my @points = ([(^100).rand, (^100).rand] xx 100).unique;

## 1
my $kdTree1;
$kdTree1 = Algorithm::KDimensionalTree.new(@points);
isa-ok $kdTree1, Algorithm::KDimensionalTree:D;

## 2
my @searchPoint1 = |@points.head;
is-deeply $kdTree1.k-nearest(@searchPoint1, 1).map(*<point>.value).Array, [@searchPoint1,];

## 3
is-deeply
        $kdTree1.k-nearest(@searchPoint1, 5).map(*<point>.value),
        $kdTree1.nearest-within-ball(@searchPoint1, 60).sort(*<distance>).map(*<point>.value)[^5],
        "Equivalence for k-nearest and within ball";

## 4
# Make verification test with direct scanning of @points.
my @nns6 = @points.sort({ sqrt [+] ($_.Array Z- @searchPoint1).map(* ** 2) });
is-deeply $kdTree1.k-nearest(@searchPoint1, 12).map(*<point>.value), @nns6[^12];

done-testing;
